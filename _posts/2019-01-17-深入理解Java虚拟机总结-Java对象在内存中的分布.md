---
layout: post
title: 深入理解Java虚拟机总结-Java对象在内存中的分布
date: 2019-02-17
author: AlstonWilliams
header-img: img/post-bg-2015.jpg
catalog: true
categories:
- JVM
tags:
- JVM
---
> 注:此文是我在读完**周志明**老师的**深入理解Java虚拟机**之后总结的一篇文章，请阅读此书获取更加详细的信息．

## Java运行时数据区

Java运行时数据区分为下面的几块区域:

- 程序计数器:线程独立的一块区域，保存了下一条指令的地址．
- 虚拟机栈: 虚拟机栈也是线程独立的一块区域，它内部包含很多个栈帧，其中每个栈帧都是由方法在运行时创建的．每个栈帧都包括了**局部变量表,操作数栈，动态链接，方法出口**等信息．局部变量表中，存放了编译期可知的各种基本数据类型(boolean, byte, char, short, int, float, double),对象引用(reference)和returnAddress(指向了一条字节码指令的地址)．

![](http://upload-images.jianshu.io/upload_images/4108852-8d837af124ede8a3.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 本地方法栈:和虚拟机栈类似，但是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为虚拟机使用到的Native方法服务.
- 堆:我们最常说的一块区域，是线程共享的一块区域，所以得对象实例以及数组都在堆上分配．可以是物理上不连续的内存空间，只要逻辑上连续即可．可以被分为新生代，老年代，永久代(某些虚拟机不支持永久代)，新生代进一步被分为Eden空间，From Survivor空间， To Survivor空间．关于堆的内存空间，我们会在以后将要介绍的垃圾回收机制中详细介绍．
- 方法区．线程共享的一块区域，用于存储已被虚拟机加载的类信息，常量，静态变量，即时编译器编译后的代码等数据．运行时常量池是方法区的一部分，用于存放编译期生成的各种字面量和符号引用，以及翻译出来的直接引用．
- 直接内存．Java虚拟机规范中没有定义此块区域，大小不受堆限制．

## Java对象的创建过程

~~~~
接收new指令

if(指令的参数能在常量池中定位到符号引用) {

  if(符号引用代表的类已被加载，解析和初始化) {

  } else {
    加载相应的类
  }

  为新生对象中分配内存(不一定在新生代分配，当对象的大小超过设定的阈值时，将会直接在老年代分配)

  将分配到的内存空间初始化为零值

  对对象进行必要的设置，比如这个对象是哪个类的实例，如何才能找到类的元数据信息，对象的哈希码，对象的GC分代年龄等信息．这些信息存放在对象的对象头之中．根据虚拟机当前的运行状态不同，如是否启用偏向锁等，对象头会有不同的设置方式．

  执行<init>方法，把对象按照程序员的意愿进行初始化．
  
}
~~~~

给对象在堆中分配内存时，根据堆是否规整，又分为下面的两种分配方式:

- (1)堆内存规整：
  堆内存是否规整取决于采用的垃圾回收器是否带有Compact过程，新生代的垃圾回收器由于普遍采用**标记-复制**算法，所以新生代堆内存一般是规整的．老年代的话，由于一般采用**标记-整理**算法，一般也是规整的．但是,CMS垃圾回收器例外．
 在堆内存规整的情况下，采用**指针碰撞**的方法．


![](http://upload-images.jianshu.io/upload_images/4108852-e6e470d66a82ca63.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- (2)堆内存不规整:
在这种情况下，需要用一张列表来维护可用的内存，在分配内存的时候，从列表中找到一块足够大的空间，划分给对象，并更新可用内存表，这种方式叫做"**空闲列表**".

![](http://upload-images.jianshu.io/upload_images/4108852-1b5a4afb0ea0ff3d.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

![](http://upload-images.jianshu.io/upload_images/4108852-8e2a67a302e7b404.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

有没有感觉其实跟操作系统中内存分配很像?

**那么如何保证为对象分配内存时，是线程安全的?**

两种解决方案:

- ①对分配内存空间的动作进行同步处理．实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性
- ②每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓存(TLAB).哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时，才需要同步锁定．虚拟机是否采用TLAB,可以通过**-xx:+/-UseTLAB**参数来设定．

## 对象的内存布局

对象在内存中大体分为三个部分:**对象头，实例数据，对齐填充**．其中**对象头**又可以被进一步划分为**运行时数据和类型指针**．对象头在32位和64位机器上分别占64位和128位．其中**运行时数据和类型指针**各占一半．

![](http://upload-images.jianshu.io/upload_images/4108852-44ae0b52912025c6.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

运行时数据又可以被细分为下面的内容:

![](http://upload-images.jianshu.io/upload_images/4108852-e45ed23acd564b40.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

当处于未锁定状态时，在32位机器上，**25bit**用于存储对象的哈希码，**4bit**用于存储对象的分代年龄，**2bit**用于存放锁标志位，**1bit**固定为0.

**类型指针**指向该对象的类对象，并不是所有的虚拟机实现都必须在对象数据上保留类型指针．如果对象是一个数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据确定数组的大小．

对象在内存中的布局中的第二部分是**实例数据**．**实例数据**包括父类和子类中的**实例字段**，不包括**实例方法**．

为什么不包括**实例方法**呢?

因为**实例方法**是**无状态**的，也就是说，一个类的实例方法是不会有任何改变的．所以，一个类只需要在方法区中维护一份实例方法即可，而不需要再在对象中保存实例方法的信息．

**实例数据**的存储顺序受虚拟机分配策略参数和字段在Java源码中定义顺序的影响．HotSpot虚拟机默认的分配策略为**longs/doubles,ints,shorts/chars,bytes/booleans, oop(Ordinary Object Pointers)**．

我们可以看到，相同宽度的字段总是被分配到一起，且父类中的变量在子类之前．如果**Compact Fields**参数为true,子类中较窄的变量也可能插入到父类变量的空隙中．

对象在内存中的布局的最后一部分是**对齐填充**．这部分是为了满足对象的起始地址必须是8字节的整数倍，即对象的大小必须是8字节的整数倍的要求．

## 对象的访问定位

我们使用**reference**对象来定位并使用对象，那么**reference**对象是如何定位对象的呢？有两种实现方式:

- 1.基于句柄
堆中专门划出一块内存作为句柄池，**reference**对象存储了句柄池中对应对象的句柄的位置．

句柄池由一个个的句柄构成，句柄又由**到实例数据的指针**和**到对象类型数据的指针**组成．

![](http://upload-images.jianshu.io/upload_images/4108852-180aa69aa763a75b.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 2.基于直接指针

![](http://upload-images.jianshu.io/upload_images/4108852-0709116c96e1145f.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

这两种方式各有优缺点:基于句柄的方式能够在对象被移动(在垃圾回收中是很常见的行为)的时候，不需要改变**reference**对象，只需要改变句柄池中对应句柄的内容．而基于直接指针的方式，则由于仅需要一次定位便能直接定位到对应的对象实例数据，所以其性能相对高一些．

目前，HotSpot虚拟机中是使用的**基于直接指针**的这种方式．但是，使用**基于句柄**的方式的应用也有很多．
