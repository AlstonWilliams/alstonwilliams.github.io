---
layout: post
title: Java集合框架源码研读-PriorityQueue
date: 2019-02-17
author: AlstonWilliams
header-img: img/post-bg-2015.jpg
catalog: true
categories:
- JDK源码研读
tags:
- JDK源码研读
---
前面我们已经介绍了好几个Map了，今天我们来介绍一个更加简单的数据结构，**PriorityQueue**.

从其名字中，我们就能看出，**PriorityQueue**首先是一个Queue,其中它的元素都是按照priority进行排序的．

那么如何实现一个**PriorityQueue**呢?

实际上有很多方法，数组，链表，堆都可以实现．因为实际上我们可以看到，它不过就是一个按照priority进行排序的一个数据结构.

我们先来分析一下**PriorityQueue**需要具有的基本操作．

首先，由于它是一个Queue,就必然要求Queue的一些特性:

- 不限容量
- 先进先出
- 只能从队首读取数据，从队尾插入数据

除此之外，由于其又增加了**Priority**的特性，这就要求其能够对其中的数据进行排序，按照优先级进行服务．

这种优先级队列的应用场景很多，比如我们熟知的进程调度算法．

我们来分析一下使用数组，链表以及堆实现它的优缺点.


## 几种实现PriorityQueue的数据结构

#### 数组实现

数组的优缺点都很明显，优点是能够根据索引从任意位置访问，进行数据存取，缺点是容量有限，再就是插入或者删除数据时，如果给定位置有数据，那么需要进行数据的移动，代价很大．

实际上，从根本上来说的话，**PriorityQueue**的实现，还就是一个数组，只不过是一种特殊形式的数组．

#### 链表实现

链表的优点是，存取数据，删除数据等很方便，以及容量无限，缺点是，遍历起来很麻烦，时间复杂度为O(n).而链表中基本所有操作的前提都是先通过遍历找到对应的元素．

所以，其所有操作的时间复杂度，如果算上定位对应元素的时间复杂度，实际上都是O(n)的.

#### 堆实现

堆又分为最大堆和最小堆．

实际上，堆的内部数据结构还是一个数组，只不过是一个特殊的数组，其逻辑结构为一棵树，一棵完全二叉树．上面我们所说的数组就是这棵完全二叉树的层序遍历的结果．

堆跟完全二叉树的区别在于其性质，其性质表明,在最大堆中，父节点是其子树的最大节点，在最小堆中，父节点是其子树的最小节点．

堆的这些性质，保证了插入和删除操作的时间复杂度为O(logn),查找操作的时间复杂度为O(1).

##　PriorityQueue的实现

具体的实现方式，上面我们也已经说过了，实际上就是一个堆，一个二叉堆.


![](http://upload-images.jianshu.io/upload_images/4108852-379fb41cf93883bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

那么为什么采用二叉堆的这种结构呢?因为上面我们已经说了，二叉堆的性能比较好．

**PriorityQueue**中的具体的各种方法，我们这里就不介绍了，就是跟Queue相关的那些操作．其各种操作，无非就是对这个堆的进行的各种操作．

## 需要注意的地方

- **PriorityQueue**不允许NULL
- **PriorityQueue**不是线程安全的，它是Fail-Fast的．
