---
layout: post
title: 操作系统IO模型(译)
date: 2019-02-17
author: AlstonWilliams
header-img: img/post-bg-2015.jpg
catalog: true
categories:
- Java-NIO
tags:
- Java-NIO
---
在学习NIO之前，我们非常有必要了解一下操作系统中的各种IO模型，否则是不会理解NIO的实现的．

这篇文章是我翻译[I/O Multiplexing: The select and poll Functions](https://notes.shichao.io/unp/ch6/)这篇文章中的前半部分关于IO模型的部分．这篇文章中，还对**select()**等系统调用有更加深入的介绍，各位不妨读一下．

## 正文

在Unix下，我们有五种不同的IO模型，分别是：
- 阻塞IO(Blocking IO)
- 非阻塞IO(Nonblocking IO)
- I/O复用(I/O Multiplexing)
- 信号驱动IO(signal driven I/O)
- 异步IO(Asynchronous IO)

对于一个读操作来说，一般会经过下面两个过程：
- 等待数据就绪．比如说，对于一个网络连接来说，就是等待数据通过连接到达主机．当数据到达主机时，把数据拷贝到内核中的缓冲区．
- 将数据从内核拷贝到进程．即把数据从内核的缓冲区拷贝到应用程序的缓冲区．

## 阻塞IO

最常用的IO模型就是阻塞IO．默认情况下，全部的socket都是阻塞的．其处理过程如下图所示：

![](http://upload-images.jianshu.io/upload_images/4108852-bef4ef01464f0bd9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

在这个例子中，我们会通过UDP而不是TCP来举例，因为对于UDP来说，**等待数据就绪**这一步更加直观：要不就是收到了一个数据报，要不就是没收到一个数据报．但是对于TCP来说，还有很多额外的变量．

上图中的**recvfrom**是一个系统调用．当我们执行一次系统调用的时候，有一次从用户态到内核态的切换．

从上图中我们可以看到，进程调用**recvfrom**之后，这个系统调用并不会立即返回，它会等到数据报到达并且被拷贝到应用程序的缓冲区中，或者出现了一个错误，才会返回．我们称这个过程是阻塞的，应用程序只有在数据报被放入缓冲区之后，才能继续进行．

## 非阻塞IO

非阻塞IO和阻塞IO相对，它会告诉内核，"当我要你完成的IO操作不能完成时，不要让进程阻塞，你给我返回一个错误就行了"．过程如下图所示：

![](http://upload-images.jianshu.io/upload_images/4108852-04a3645d0c84aeaa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 在上面的三个**recvfrom**操作中，由于数据并没有就绪，所以内核返回了一个**EWOULDBLOCK**错误．
- 在第四个**recvfrom**中，数据已经就绪了，并且已经被拷贝到我们的应用程序的缓冲区了，内核返回一个**OK**，然后我们的应用程序处理这些数据．

我们可以看到，在这种模型中，我们需要使用轮询的方式来确定数据到底是否就绪．尽管这会浪费CPU时间，但是仍然是比较常见的模型，一般是在系统函数中用到．

## I/O多路复用

在I/O多路复用中，我们会调用**select()**或者**poll()**，并且阻塞在这两个系统调用上．而不是阻塞在**recvfrom**这个实际的IO操作的系统调用上．下面是I/O多路复用模型的过程图：

![](http://upload-images.jianshu.io/upload_images/4108852-827bf0d5f5acd51d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

从上图中，我们可以看到，我们会阻塞在**select()**这个系统调用上，并等待数据到达．当**select()**告诉我们数据到达时，再通过**recvfrom**系统调用将数据拷贝到应用程序的缓冲区．

看到这里，如果各位不了解**select()**，可能就会有一个疑问．你这不是脱了裤子放屁吗？这不是还是跟阻塞IO模型一样，还是阻塞吗？只不过现在不是阻塞在**recvfrom**上，而是阻塞在**select**上而已．而且，现在还多了一次系统调用，那效率不是更低吗？

多了一次系统调用，确实是I/O多路复用模型的缺点．但是存在即合理，它也有优点．

它的优点在于，**select**可以同时监听多个文件描述符，以及感兴趣的事件．所以，我们可以在一个线程中完成之前需要好多个线程才能完成的事情．

比如，我们想要同时从一个接受来自Socket的数据，以及从文件中读数据．在阻塞IO模型中，我们会这么做：

~~~~
  1．创建一个线程A，在其中创建一个Socket Server，并通过它的accept()方法，等待客户端的连接并处理数据
  2．创建一个线程B，在其中打开文件并且读数据．
~~~~

这就需要两个线程，对吧？

而且我们又知道，线程之间的切换是有开销的，也是需要涉及到用户态到内核态的转换．

而我们在I/O多路复用模型中，可以这样做：
~~~~
  1．通过注册函数告诉系统，应用程序对于Socket的读事件以及文件的读事件感兴趣
  2．通过轮询调用select()方法，查看哪些我们感兴趣的事件已经发生了
  3．在同一个线程中，依次进行对应的操作
~~~~

我们可以看到，在这里我们只需要用一个线程就可以做到在阻塞IO中我们需要两个线程才能做到的事情．这就是I/O复用中的**复用**的含义．

## 信号驱动IO

信号驱动IO使用信号量机制，它告诉内核，当文件描述符准备就绪时，通过**SIGIO**信号通知我们．过程如下：

![](http://upload-images.jianshu.io/upload_images/4108852-3af84574930641b7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 我们首先通过**sigaction**系统调用安装一个事件处理器．这个操作会立即返回．所以我们的应用程序会继续运行，而不会阻塞．
- 当数据准备就绪时，内核会给我们的应用程序发出一个**SIGIO**信号，我们可以继续进行下面的处理：
  - 在信号处理器中，通过**recvfrom**系统调用将数据从内核缓冲区读取到应用程序缓冲区中
  - 告诉应用程序从缓冲区读取数据并且处理

这种模型的优点是，在等待数据就绪时，应用程序并不会被阻塞．应用程序可以继续运行，只需要在数据就绪时，让时间处理器通知它即可．

## 异步IO

异步IO模型跟事件驱动IO模型类似，也是告诉内核，在一定情况下通知我们．但是它跟事件驱动IO模型不同的是，在事件驱动IO模型中，内核会在数据就绪，即数据被拷贝到内核缓冲区时，通知我们．而在异步IO中，内核会在整个操作都被完成，即数据从内核缓冲区拷贝到应用程序缓冲区时，通知我们．如下图所示：

![](http://upload-images.jianshu.io/upload_images/4108852-a7b211d03ef0ed7e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 我们调用**aio_read**这个系统调用，并且给内核传递下面的数据：
  - 文件描述符，缓冲区指针，缓冲区大小
  - 文件偏移量
  - 当整个操作完成时，如何通知我们
这个系统调用会立即返回，在整个操作完成之前，不会被阻塞

## 五种IO模型的比较

![](http://upload-images.jianshu.io/upload_images/4108852-b7ee9ccefa6cbc86.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

## 同步IO和异步IO

POSIX中，定义了下面的两个术语：

- 同步IO：在整个IO操作完成之前，会导致应用程序阻塞的IO操作叫做同步IO
- 异步IO：在整个IO操作完成之前，不会导致应用程序阻塞的IO操作叫做异步IO

我们可以看到，上面我们定义的五个IO模型，前四个(阻塞IO模型，非阻塞IO模型，IO复用模型，信号驱动模型)都属于同步IO，而只有异步IO模型属于异步IO．

## 注意

原文中还有更多关于**select**等IO复用的详细介绍，所以强烈建议各位读一下原文．
